<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: hungtask - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">hungtask</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-08T11:00:00.000Z" title="9/8/2020, 7:00:00 PM">2020-09-08</time>发表</span><span class="level-item"><time dateTime="2021-02-19T06:01:01.845Z" title="2/19/2021, 2:01:01 PM">2021-02-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">10 分钟读完 (大约1572个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/08/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hung_task%E9%97%AE%E9%A2%98/">linux hungtask问题</a></h1><div class="content"><h2 id="hungtask-定义"><a href="#hungtask-定义" class="headerlink" title="hungtask 定义"></a>hungtask 定义</h2><p>我们先看一段实际hungtask的 dmesg打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[45312.818392] INFO: task ftpd:17682 blocked for more than 120 seconds.</span><br><span class="line">[45312.818470]       Tainted: G           OE     5.4.44 #1</span><br><span class="line">[45312.818472] &quot;echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;hung_task_timeout_secs&quot; disables this message.</span><br><span class="line">[45312.818474] ftpd     D    0 17682      2 0x80004000</span><br><span class="line">[45312.818478] Call Trace:</span><br><span class="line">[45312.818698]  __schedule+0x2e3&#x2F;0x740</span><br><span class="line">[45312.818700]  schedule+0x42&#x2F;0xb0</span><br><span class="line">[45312.818702]  schedule_timeout+0x152&#x2F;0x2f0</span><br><span class="line">[45312.818755]  ? __next_timer_interrupt+0xe0&#x2F;0xe0</span><br><span class="line">[45312.818756]  msleep+0x2e&#x2F;0x40</span><br><span class="line">[45312.818760]  ftpd+0xaa&#x2F;0x170 [ftpd]</span><br><span class="line">[45312.818804]  kthread+0x104&#x2F;0x140</span><br><span class="line">[45312.818806]  ? 0xffffffffc05bb000</span><br><span class="line">[45312.818807]  ? kthread_park+0x90&#x2F;0x90</span><br><span class="line">[45312.818808]  ret_from_fork+0x35&#x2F;0x40</span><br></pre></td></tr></table></figure>
<p>第一行就写了 pid为 17682的 task被 block阻塞了超过120s得不到执行，这种往往只是打印hungtask的线程 和 backtrace而已，实际中一般也不会导致panic，但是这种问题确是我们不能忽略的点，有可能这就是后面会出事故的点</p>
<p>hungtask是内核的一种自我保护行为，在检测到一个线程长时间（可设置）处于D状态之后，会打印出线程相关信息和backtrace.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh@ubuntu:&#x2F;var&#x2F;crash$ ps -aux |grep ftpd</span><br><span class="line">root       18007  0.0  0.0      0     0 ?        D    01:01   0:00 [ftpd]</span><br></pre></td></tr></table></figure>

<p>D 状态也是进程的一种状态，对应内核中的 TASK_UNINTERRUPTIBLE 状态，一般等待磁盘IO的线程会设置为 TASK_UNINTERRUPTIBLE 状态，此状态无法wakeup，不管是 wake_up_process，还是kill -9去尝试杀死他 都不能将 TASK_UNINTERRUPTIBLE 状态线程唤醒，只有等他自己wakeup。</p>
<p>同时linux内核在统计系统load的时候也将 TASK_UNINTERRUPTIBLE 状态的现场统计了进去，这样如果系统中出现D状态线程之后，整体系统的load就会较高，但是CPU loading却很小，几乎为0。这种统计方式也使得linux系统中loadavg这个参考指标的意义不是那么的大了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sh@ubuntu:~$ top</span><br><span class="line">top - 01:04:54 up 13:09,  3 users,  load average: 2.05, 1.06, 0.49</span><br><span class="line">Tasks: 341 total,   1 running, 340 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   3716.5 total,    249.5 free,   2034.2 used,   1432.7 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1557.2 free,    490.8 used.   1398.5 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">   2253 rlk       20   0  299752  13200  10788 S   0.3   0.3   0:36.83 vmtoolsd</span><br><span class="line">  18184 rlk       20   0   20700   4292   3384 R   0.3   0.1   0:00.08 top</span><br></pre></td></tr></table></figure>

<p>什么样的线程会处于D状态，即 TASK_UNINTERRUPTIBLE 状态呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 磁盘IO线程，在等待磁盘读入数据的过程中会将自己设置为 TASK_UNINTERRUPTIBLE 状态</span><br><span class="line">2. 还有一个 msleep()，这个API会先将线程状态设置为 TASK_UNINTERRUPTIBLE,再调用 schedule_timeouot()</span><br><span class="line"></span><br><span class="line">void msleep(unsigned int msecs)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long timeout &#x3D; msecs_to_jiffies(msecs) + 1;</span><br><span class="line"></span><br><span class="line">	while (timeout)</span><br><span class="line">		timeout &#x3D; schedule_timeout_uninterruptible(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="config配置-hung-task"><a href="#config配置-hung-task" class="headerlink" title="config配置 hung_task"></a>config配置 hung_task</h2><p>需要开启如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;CONFIG_DETECT_HUNG_TASK&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_DEFAULT_HUNG_TASK_TIMEOUT&#x3D;120&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_BOOTPARAM_HUNG_TASK_PANIC&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE&#x3D;1&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br></pre></td></tr></table></figure>


<h2 id="hungtask-检测的实现"><a href="#hungtask-检测的实现" class="headerlink" title="hungtask 检测的实现"></a>hungtask 检测的实现</h2><p>上面讲了hungtask的原理，下面通过代码走读的方式来分析一下hungtask实现细节</p>
<p>首先是init, hungtask机制在初始化的时候使用kthread_run 运行了一个 [khungtaskd]线程，hungtask 主要工作就是在 hungtaskd 线程中完成的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这是主要干活的</span><br><span class="line">static void check_hung_task(struct task_struct *t, unsigned long timeout)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long switch_count &#x3D; t-&gt;nvcsw + t-&gt;nivcsw;</span><br><span class="line"></span><br><span class="line">	if (switch_count !&#x3D; t-&gt;last_switch_count) &#123; &#x2F;&#x2F;此task 没有hungtask</span><br><span class="line">		t-&gt;last_switch_count &#x3D; switch_count;</span><br><span class="line">		t-&gt;last_switch_time &#x3D; jiffies;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if (time_is_after_jiffies(t-&gt;last_switch_time + timeout * HZ))</span><br><span class="line">		return; &#x2F;&#x2F; 此task虽然hung了，但是还未到 120s &#x3D;&#x3D; 120 * HZ</span><br><span class="line"></span><br><span class="line">	if (sysctl_hung_task_warnings) &#123;</span><br><span class="line">		pr_err(&quot;INFO: task %s:%d blocked for more than %ld seconds.\n&quot;,</span><br><span class="line">		       t-&gt;comm, t-&gt;pid, (jiffies - t-&gt;last_switch_time) &#x2F; HZ);</span><br><span class="line">		xxxx &#x2F;&#x2F;提示信息</span><br><span class="line">		sched_show_task(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Check whether a TASK_UNINTERRUPTIBLE does 