<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: valgrind - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">valgrind</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-17T11:00:00.000Z" title="1/17/2021, 7:00:00 PM">2021-01-17</time>发表</span><span class="level-item"><time dateTime="2021-01-21T09:06:22.284Z" title="1/21/2021, 5:06:22 PM">2021-01-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">12 分钟读完 (大约1859个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/17/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/valgrind%20%E5%AE%9A%E4%BD%8D%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">valgrind 定位用户空间内存泄漏</a></h1><div class="content"><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>在实际开发中，某个应用程序如果存在内存泄露，且是长时间运行的程序，就会导致比较严重的后果。<br>在一些业务场景的长跑测试中，这些问题往往会充分暴露出来。</p>
<p>一般情况下这种内存泄漏都是以 OOM Kill 而结尾的。 kmsg log 往往只有 这个进程确实消耗了大量进<br>程的证据，但是无法确切知道是哪里的内存泄漏，这里就需要一个工具来帮助检测，如果是发生内存泄漏之后<br>仅仅通过人肉去分析代码，往往很困难。</p>
<p>valgrind 就是这样一款 强大的工具：</p>
<ol>
<li>检查用户空间内存泄漏</li>
<li>检查</li>
</ol>
<h2 id="valdrind-原理"><a href="#valdrind-原理" class="headerlink" title="valdrind 原理"></a>valdrind 原理</h2><h2 id="valdrind-安装，使用"><a href="#valdrind-安装，使用" class="headerlink" title="valdrind 安装，使用"></a>valdrind 安装，使用</h2><p>直接安装， ubuntu 官方软件源已经包含了，其他平台可以通过源码编译安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@100ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# sudo apt install valgrind</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following packages were automatically installed and are no longer required:</span><br><span class="line">  openbsd-inetd openjdk-11-jdk-headless tcpd update-inetd</span><br><span class="line">Use &#39;sudo apt autoremove&#39; to remove them.</span><br><span class="line">Suggested packages:</span><br><span class="line">  valgrind-dbg valgrind-mpi kcachegrind alleyoop valkyrie</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  valgrind</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 231 not upgraded.</span><br><span class="line">Need to get 20.3 MB of archives.</span><br><span class="line">After this operation, 90.0 MB of additional disk space will be used.</span><br><span class="line">Get:1 https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu focal-updates&#x2F;main amd64 valgrind amd64 1:3.15.0-1ubuntu9.1 [20.3 MB]</span><br><span class="line">48% [1 valgrind 12.2 MB&#x2F;20.3 MB 60%]</span><br><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# ls</span><br></pre></td></tr></table></figure>

<p>使用如下代码检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 3;</span><br><span class="line">        char *p &#x3D; NULL;</span><br><span class="line">        p &#x3D; malloc(1024 * 1024);</span><br><span class="line">        if (!p)</span><br><span class="line">                printf(&quot;malloc failed,just wait!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        printf(&quot;malloc sucess,just wait!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        while(i--) &#123;</span><br><span class="line">                usleep(1000 * 1000);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于 valgrind 不好的地方在于：</p>
<ol>
<li><p>对于想使用 valgrind来检查内存泄漏的业务来说，必须从开始 用valgrind 启动，意味着对于业务<br>需要重启。还有比如很难复现的内存泄漏，等你重启业务用 valgrind来启动，说不定又不复现了。。</p>
</li>
<li><p>对于 valgrind 启动的业务来说，会比直接启动有一些性能损失。</p>
</li>
</ol>
<h3 id="userspace-memleak-demo"><a href="#userspace-memleak-demo" class="headerlink" title="userspace memleak demo"></a>userspace memleak demo</h3><p>使用上面代码 直接用 <code>valgrind</code> 启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# valgrind .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Command: .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">malloc sucess,just wait!!</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 bytes allocated</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; LEAK SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    definitely lost: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    still reachable: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;         suppressed: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Rerun with --leak-check&#x3D;full to see details of leaked memory</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>HEAP SUMMARY:</code> 中写了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 bytes allocated</span><br></pre></td></tr></table></figure>
<p>在进程退出时，仍然有 <code>1048576 bytes</code> 内存在使用中，这部分就是泄漏的内存。但是我们仍然不能确<br>定到底是哪里泄漏的内存，按照他的建议 加上 <code>-leak-check=full</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# valgrind  --leak-check&#x3D;full  .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Command: .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">malloc sucess,just wait!!</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 b