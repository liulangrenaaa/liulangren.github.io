<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>关于preempt_count的思考 - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="preempt_conut 本质就是一个int型的数，是每个 task_struct 的 thread_info 的一个成员变量，但是他和系统的调度密切相关，当然也十分重要。 12345struct thread_info &amp;amp;#123;	unsigned long		flags;		&amp;#x2F;* low level flags *&amp;#x2F;	int			preempt_count;	&amp;amp;#x2F"><meta property="og:type" content="blog"><meta property="og:title" content="关于preempt_count的思考"><meta property="og:url" content="https://liulangrenaaa.github.io/2020/09/21/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8Epreempt_count%E7%9A%84%E6%80%9D%E8%80%83/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:description" content="preempt_conut 本质就是一个int型的数，是每个 task_struct 的 thread_info 的一个成员变量，但是他和系统的调度密切相关，当然也十分重要。 12345struct thread_info &amp;amp;#123;	unsigned long		flags;		&amp;#x2F;* low level flags *&amp;#x2F;	int			preempt_count;	&amp;amp;#x2F"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:published_time" content="2020-09-21T11:00:00.000Z"><meta property="article:modified_time" content="2021-02-19T06:01:01.845Z"><meta property="article:author" content="Su Hui"><meta property="article:tag" content="内核同步"><meta property="article:tag" content="进程调度"><meta property="article:tag" content="preempt_count"><meta property="article:tag" content="内核抢占"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io/2020/09/21/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8Epreempt_count%E7%9A%84%E6%80%9D%E8%80%83/"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"datePublished":"2020-09-21T11:00:00.000Z","dateModified":"2021-02-19T06:01:01.845Z","author":{"@type":"Person","name":"Su Hui"},"description":"preempt_conut 本质就是一个int型的数，是每个 task_struct 的 thread_info 的一个成员变量，但是他和系统的调度密切相关，当然也十分重要。 12345struct thread_info &amp;#123;\tunsigned long\t\tflags;\t\t&#x2F;* low level flags *&#x2F;\tint\t\t\tpreempt_count;\t&amp;#x2F"}</script><link rel="canonical" href="https://liulangrenaaa.github.io/2020/09/21/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8Epreempt_count%E7%9A%84%E6%80%9D%E8%80%83/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-21T11:00:00.000Z" title="9/21/2020, 7:00:00 PM">2020-09-21</time>发表</span><span class="level-item"><time dateTime="2021-02-19T06:01:01.845Z" title="2/19/2021, 2:01:01 PM">2021-02-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">8 分钟读完 (大约1165个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">关于preempt_count的思考</h1><div class="content"><p>preempt_conut 本质就是一个int型的数，是每个 <code>task_struct</code> 的 <code>thread_info</code> 的一个成员变量，但是他和系统的调度密切相关，当然也十分重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct thread_info &#123;</span><br><span class="line">	unsigned long		flags;		&#x2F;* low level flags *&#x2F;</span><br><span class="line">	int			preempt_count;	&#x2F;* 0 &#x3D;&gt; preemptable, &lt;0 &#x3D;&gt; bug *&#x2F;</span><br><span class="line">    .......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>inlcude/linux/preempt.h</code> 文件看相关定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline int preempt_count(void)</span><br><span class="line">&#123;</span><br><span class="line">	return READ_ONCE(current_thread_info()-&gt;preempt_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> *         PREEMPT_MASK:	0x000000ff</span><br><span class="line"> *         SOFTIRQ_MASK:	0x0000ff00</span><br><span class="line"> *         HARDIRQ_MASK:	0x000f0000</span><br><span class="line"> *             NMI_MASK:	0x00100000</span><br><span class="line"> * PREEMPT_NEED_RESCHED:	0x80000000</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define PREEMPT_BITS	8</span><br><span class="line">#define SOFTIRQ_BITS	8</span><br><span class="line">#define HARDIRQ_BITS	4</span><br><span class="line">#define NMI_BITS	1</span><br><span class="line"></span><br><span class="line">#define PREEMPT_SHIFT	0</span><br><span class="line">#define SOFTIRQ_SHIFT	(PREEMPT_SHIFT + PREEMPT_BITS)</span><br><span class="line">#define HARDIRQ_SHIFT	(SOFTIRQ_SHIFT + SOFTIRQ_BITS)</span><br><span class="line">#define NMI_SHIFT	(HARDIRQ_SHIFT + HARDIRQ_BITS)</span><br><span class="line"></span><br><span class="line">#define hardirq_count()	(preempt_count() &amp; HARDIRQ_MASK)</span><br><span class="line">#define softirq_count()	(preempt_count() &amp; SOFTIRQ_MASK)</span><br><span class="line">#define irq_count()	(preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span><br><span class="line">				 | NMI_MASK))</span><br><span class="line"></span><br><span class="line">#define in_irq()		(hardirq_count())</span><br><span class="line">#define in_softirq()		(softirq_count())</span><br><span class="line">#define in_interrupt()		(irq _count())</span><br><span class="line">#define in_serving_softirq()	(softirq_count() &amp; SOFTIRQ_OFFSET)</span><br><span class="line">#define in_nmi()		(preempt_count() &amp; NMI_MASK)</span><br><span class="line">#define in_task()		(!(preempt_count() &amp; \</span><br><span class="line">				   (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>preempt_count</code> 0-7 bit被用来抢占计数，8-15 bit被用来软中断计数，16-19 bit被用来硬件中断计数，20bit 被用来 NMI中断计数，31 bit被用来记录是否需要立即sched.</p>
<p>in_interrupt() 这些宏本质也是根据 preempt_count()来判断的。</p>
<h2 id="hard-irq"><a href="#hard-irq" class="headerlink" title="hard irq"></a>hard irq</h2><p>在进入irq的时候通过 <code>irq_enter</code> 将preempt_count 的 16-19bit ++，在退出irq的时候通过 <code>irq_exit</code> 将preempt_count 的 16-19bit –，但是由于目前linux中的中断往往是不可嵌套的，所以一般 hardirq 只会用到 16 bit，为什么linux给 hardirq 保留了4bit呢，這是歷史原因造成的，早期hardirq还是可以嵌套的。</p>
<p>irq_enter()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define preempt_count_add(val)	__preempt_count_add(val)</span><br><span class="line"></span><br><span class="line">#define __irq_enter()					\</span><br><span class="line">	do &#123;						\</span><br><span class="line">		account_irq_enter_time(current);	\</span><br><span class="line">		preempt_count_add(HARDIRQ_OFFSET);	\  &#x2F;&#x2F; preempt_count 和 hardirq相关++</span><br><span class="line">		trace_hardirq_enter();			\</span><br><span class="line">	&#125; while (0)</span><br><span class="line"></span><br><span class="line">void irq_enter(void) &#x2F;&#x2F;进入中断上下文</span><br><span class="line">&#123;</span><br><span class="line">	rcu_irq_enter();</span><br><span class="line">	if (is_idle_task(current) &amp;&amp; !in_interrupt()) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Prevent raise_softirq from needlessly waking up ksoftirqd</span><br><span class="line">		 * here, as softirq will be serviced on return from interrupt.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		local_bh_disable();</span><br><span class="line">		tick_irq_enter();</span><br><span class="line">		_local_bh_enable();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__irq_enter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>irq_exit()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define preempt_count_sub(val)	__preempt_count_sub(val)</span><br><span class="line"></span><br><span class="line">void irq_exit(void) &#x2F;&#x2F;退出中断上下文</span><br><span class="line">&#123;</span><br><span class="line">#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED</span><br><span class="line">	local_irq_disable();</span><br><span class="line">#else</span><br><span class="line">	lockdep_assert_irqs_disabled();</span><br><span class="line">#endif</span><br><span class="line">	account_irq_exit_time(current);</span><br><span class="line">	preempt_count_sub(HARDIRQ_OFFSET); &#x2F;&#x2F; preempt_count 和 hardirq相关--</span><br><span class="line">	if (!in_interrupt() &amp;&amp; local_softirq_pending())</span><br><span class="line">		invoke_softirq();</span><br><span class="line"></span><br><span class="line">	tick_irq_exit();</span><br><span class="line">	rcu_irq_exit();</span><br><span class="line">	trace_hardirq_exit(); &#x2F;* must be last! *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="soft-irq"><a href="#soft-irq" class="headerlink" title="soft irq"></a>soft irq</h2><p>preempt_count中的第8到15个bit表示softirq count，它记录了进入softirq的嵌套次数，如果softirq count的值为正数，说明现在正处于softirq上下文中。<br>由于softirq在单个CPU上是不会嵌套执行的，因此和hardirq count一样，实际只需要一个bit(bit 8)就可以了。<br>还有一种情况，softirq count 会用到不止 bit8，在禁用中断下半部的情况下，每禁用一次softirq count 就会增加1，理论上最多可以嵌套16次。</p>
<p>进入退出软中断的case</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1