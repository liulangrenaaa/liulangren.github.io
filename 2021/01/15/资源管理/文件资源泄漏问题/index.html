<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>文件资源泄漏问题 - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="资源泄漏资源泄漏在实际编程中是一不小心就会遇到的一个问题，最常见的就是 内存泄漏。内存泄漏：对于短时间存在的进程，线程即使存在内存泄漏，往往也不会变现出来，开发人员也很难感知到。但是一旦是长时间运行的进程，线程存在内存泄漏的问题，那将是一个灾难，要么过一会被OOM KILL，要么自己重启，更严重的就是重启机器。 内存泄漏是指内存被分配出来，但是后续一直未使用，且失去了这个内存的引用，一直无法释放的"><meta property="og:type" content="blog"><meta property="og:title" content="文件资源泄漏问题"><meta property="og:url" content="https://liulangrenaaa.github.io/2021/01/15/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:description" content="资源泄漏资源泄漏在实际编程中是一不小心就会遇到的一个问题，最常见的就是 内存泄漏。内存泄漏：对于短时间存在的进程，线程即使存在内存泄漏，往往也不会变现出来，开发人员也很难感知到。但是一旦是长时间运行的进程，线程存在内存泄漏的问题，那将是一个灾难，要么过一会被OOM KILL，要么自己重启，更严重的就是重启机器。 内存泄漏是指内存被分配出来，但是后续一直未使用，且失去了这个内存的引用，一直无法释放的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:published_time" content="2021-01-15T11:00:00.000Z"><meta property="article:modified_time" content="2021-01-18T06:07:42.051Z"><meta property="article:author" content="Su Hui"><meta property="article:tag" content="资源泄漏"><meta property="article:tag" content="文件描述符泄漏"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io/2021/01/15/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"datePublished":"2021-01-15T11:00:00.000Z","dateModified":"2021-01-18T06:07:42.051Z","author":{"@type":"Person","name":"Su Hui"},"description":"资源泄漏资源泄漏在实际编程中是一不小心就会遇到的一个问题，最常见的就是 内存泄漏。内存泄漏：对于短时间存在的进程，线程即使存在内存泄漏，往往也不会变现出来，开发人员也很难感知到。但是一旦是长时间运行的进程，线程存在内存泄漏的问题，那将是一个灾难，要么过一会被OOM KILL，要么自己重启，更严重的就是重启机器。 内存泄漏是指内存被分配出来，但是后续一直未使用，且失去了这个内存的引用，一直无法释放的"}</script><link rel="canonical" href="https://liulangrenaaa.github.io/2021/01/15/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T11:00:00.000Z" title="1/15/2021, 7:00:00 PM">2021-01-15</time>发表</span><span class="level-item"><time dateTime="2021-01-18T06:07:42.051Z" title="1/18/2021, 2:07:42 PM">2021-01-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">7 分钟读完 (大约992个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">文件资源泄漏问题</h1><div class="content"><h2 id="资源泄漏"><a href="#资源泄漏" class="headerlink" title="资源泄漏"></a>资源泄漏</h2><p>资源泄漏在实际编程中是一不小心就会遇到的一个问题，最常见的就是 <code>内存泄漏</code>。<br>内存泄漏：对于短时间存在的进程，线程即使存在内存泄漏，往往也不会变现出来，开发人员也很难感知到。<br>但是一旦是长时间运行的进程，线程存在内存泄漏的问题，那将是一个灾难，要么过一会被OOM KILL，要么<br>自己重启，更严重的就是重启机器。</p>
<p>内存泄漏是指内存被分配出来，但是后续一直未使用，且失去了这个内存的引用，一直无法释放的问题。</p>
<p>但是除了最常见内存泄漏之外，还有其他各种资源泄漏的问题，比如这次的 <code>进程文件资源泄漏</code>。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>虽然是嵌入式平台，也有一些业务需要做压力测试连续几天到一个月不关机长时间跑测试。</p>
<p>某个业务在运行两天之后就会出现进程挂掉的问题。</p>
<h2 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h2><p>如果能用简单代码复现的问题，都不大</p>
<p><a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/tree/main">代码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#define DIR_NAME        &quot;&#x2F;tmp&#x2F;asdf&quot;</span><br><span class="line"></span><br><span class="line">int sync_dir(char *dir)</span><br><span class="line">&#123;</span><br><span class="line">        if(!dir) return -1;</span><br><span class="line">        int fd &#x3D; open(dir, O_ASYNC);</span><br><span class="line">        if (-1 &#x3D;&#x3D; fd) return -1;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int ret &#x3D; -1;</span><br><span class="line">        for (i &#x3D; 0; i &lt; 1024 * 1024 * 64; i++) &#123;</span><br><span class="line">                ret &#x3D; sync_dir(DIR_NAME);</span><br><span class="line">                if (ret)        printf(&quot;sync_dir failed. i &#x3D; %d, ret &#x3D; %d\n&quot;, i, ret);</span><br><span class="line">                else            printf(&quot;sync_dir sucess. i &#x3D; %d\n&quot;, i);</span><br><span class="line">                usleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>嵌入式设备上的资源限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@device_gls:&#x2F;proc&#x2F;sys&#x2F;fs # cat file-nr</span><br><span class="line">800     0       21378</span><br><span class="line">root@device_gls:&#x2F;proc&#x2F;sys&#x2F;fs #</span><br></pre></td></tr></table></figure>
<p>意思是当前系统允许打开 <code>21378</code> 个文件，已经打开了 <code>800</code>个文件了</p>
<p>我选择用 <code>ubuntu</code> 系统去复现，先将 系统 fd上限制调制与设备一样的水平</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-max</span><br><span class="line">9223372036854775807</span><br><span class="line">tencent_clould@1ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# sudo su</span><br><span class="line">VM-0-11-ubuntu# echo 21378 &gt; file-max</span><br><span class="line">VM-0-11-ubuntu# exit</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-max</span><br><span class="line">21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs#</span><br></pre></td></tr></table></figure>

<p>尝试复现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@130ubuntu: ~&#x2F;workspace&#x2F;hexo_blog&#x2F;source&#x2F;_posts&#x2F;资源管理# .&#x2F;a.out</span><br><span class="line">sync_dir sucess. i &#x3D; 0</span><br><span class="line">sync_dir sucess. i &#x3D; 1</span><br><span class="line">....</span><br><span class="line">sync_dir sucess. i &#x3D; 5</span><br><span class="line">sync_dir sucess. i &#x3D; 18194</span><br><span class="line">sync_dir sucess. i &#x3D; 18195</span><br><span class="line">...</span><br><span class="line">sync_dir failed. i &#x3D; 18196, ret &#x3D; -1</span><br></pre></td></tr></table></figure>


<p>同时观察 <code> /proc/sys/fs/file-nr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">4704    0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">9824    0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">17760   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">20224   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">21024   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">21216   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">zsh: pipe failed: too many open files in system</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">zsh: pipe failed: too many open files in system</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>a.out</code> 最后无法 通过 <code>open</code> 打开文件了，且同时 <code>zsh</code> shell 都无法打开<br><code>file-nr